Als eindopdracht voor CSD ga ik niet een 1st order Markov chain maken, maar een 2nd order Markov Chain. Om dit goed uit te leggen, leg ik eerst de 1st order Markov Chain uit, vanuit daar is de 2nd order Markov Chain makkelijker te begrijpen. 
De 1st order Markov Chain bepaalt op basis van het event dat hij net gegenereerd heeft het volgende event dmv kans. Voor elk event zijn er probabilities voor het event daarna. Dit wordt bepaald met een weighted random functie. Bijvoorbeeld: Na een kick is er 0.8 kans op een hihat en 0.2 kans op een snare. Bij een second order Markov chain wordt de staat niet alleen bepaald door het laatst gegenereerde event, maar ook het event daarvoor. Dus bijvoorbeeld: Als er eerst een kick en dan een snare, of eerst een hihat en dan een snare wordt gespeeld maakt uit, dit geeft verschillende kanswaardes. Vandaar 2nd order: het kijkt 2 stapjes terug in de tijd. 


Als eerst genereer ik een lookup table voor de kanswaardes. Deze moet 3 dimensionaal zijn: een dimensie voor de 2nd order, de 1st order en dan een dimensie voor de kanswaardes voor de volgende events. Dit doe ik door 3 forloops te nesten die een 3 dimensionale array genereren. Ook zorg ik dat de kansen over 1 axis optellen tot 1 om mooie kanswaardes te krijgen.


Om de sequence te beginnen, moet ik eerst de sequence kickstarten (haha) met 2 waardes, zodat de Markov chain werkt. Ik begin met een kick op index 0, dan leid ik uit de lookup table af wat een grote kans had daarvoor te komen (of ik genereer het random). Op basis van deze twee events genereer ik het event op index 1, door in de lookup tabel te kijken en een weighted random functie uit te voeren met de kanswaarden.
Nu de eerste 2 events vast staan in de sequence kan de loop worden gestart waar de volgende events worden vastgesteld op dezelfde manier. Om een maatsoort erin te verwerken komt automatisch een kick op de één van de gekozen maatsoort. 
Je kunt zoveel geluiden als je wilt in het programma zetten. Ze horen thuis in het mapje sounds. De naam conventie is: 0.wav 1.wav 2.wav enz... Onder 1.wav wordt een kick verwacht, onder 0.wav is het logisch stilte onder te brengen. 

flow:

user input
|
v
genereer kanswaardes
|
v
voer Markov chain uit
|
v
Speel sequence



De verwachte voordelen van dit algoritme zijn: 
* Er ontstaan herkenbare patronen
* Makkelijk uit te bereiden voor meerdere geluiden
* Simpel te implementeren


Nadelen:
* Er kan maar één geluid tegelijk worden gespeeld

Mees Magnus van den Berg
